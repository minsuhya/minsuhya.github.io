---
theme: gaia
paginate: true
backgroundImage: url('https://marp.app/assets/hero-background.svg');
header: 'Software Engineering'
footer: '김준혁 - 정보관리기술사'
style: |
  section {background-color: #eeeeee; font-size: 32px; font-family: 'Binggrae' 'Malgun Gothic'; font-weight:bold;}
  ul {font-size: 30px; font-family: 'Binggrae' 'Malgun Gothic'; font-weight: bold;}
  h1 {font-size: 50px; color: #000; font-weight: bold; font-family: 'Binggrae'  'Malgun Gothic';}
  h3 {color: #4E6181; font-weight:bold;}
  header {background-color: black; color: white; padding: 0px 0px 0px 20px; height: 50px; font-weight: bold;}
  footer {background-color: #cccccc; color: #333333; font-weight: bold;}
  pre {background-color: #333333;}
  pre code{color:white; font-family: 'Binggrae' 'Malgun Gothic';}
size: 16:9
marp: true
---

# SW 공학
    하드웨어를 동작시켜 사용자가 작업을 편리하게 수행하도록하는 프로그램과 자료구조
    프로그램 개발, 운용, 유지보수 관련 모든 문서 및 정보 포함

	상품성   : 개발 SW는 상품화 및 판매
    견고성   : 일부 수정은 SW 전체 영향 가능
    복잡성   : 개발과정 복잡, 비표준화
    순응성   : 사용자 요구나 환경 변화에 적절히 변경
    비가시성 : SW 구조는 외관으로 나타나지 않고 코드로 숨겨진다.
    비마모성 : 마모되거나 소멸되지 않는다.
    비제조성 : 하드웨어처럼 제작이 아닌 논리적 절차에 맞게 개발
	비과학성 : 과학적이 아니라 조직, 인력, 시간, 절차 등 중심

---

# SW 분류
    기능          : 시스템, 응용
    사용          : 프로그래밍, 문서, 통신, 분산처리, 멀티미디어, 개발, 인공지능
    개발 과정     : 프로토타입, 프로젝트 산출물, 패키지
    정보처리 방법 : 일괄처리, 온라인, 실시간

# 시스템 구성요소
    입력   : 처리 방법, 처리 데이터, 조건을 시스템에 투입
    처리   : 입력 데이터를 처리 방법과 조건에 따라 처리
    출력   : 처리된 결과 시스템에서 산출
    제어   : 자료의 입력부터  출력까지 처리 과정 올바른지 감독
    피드백 : 출력 결과와 예정 목표가 다를 시 목표 달성을 위해 반복 처리

---

# SW 위기
    여러가지 원인 기반 (개발속도 < 하드웨어 개발속도) 사용자 요구사항 처리 문제 발생
    SW 특징 이해 부족 : 논리적인 SW 특징 이해 부족
    SW 관리 부재      : 효율적 자원 통제 미비
    프로그래밍 치중   : SW 품질/유지보수 미고려, 프로그래밍만으로 복잡/다양한 요구사항 처리 불만족
    개발 인력 부족 => 인건비 상승
    성능 및 신뢰성 부족
    개발 기간 지연 및 개발 비용 증가
    유지보수성 저하 => 비용 증가
    SW 생산성 및 품질 저하

---

# SW 공학
    SW 위기 극복위한 방안을 연구하는 학문
    SW 품질과 생산성 향상 목적
    
    IEEE 정의: 
        SW 개발, 운용, 유지보수, 폐기 처분에 대한 체계적인 접근 방안
    Fairley 정의: 
        지정된 비용과 기간 내의 SW의 체계적 생산과 유지보수에 관련된 기술적/관리적 원리
    Boehm 정의: 
        과학적 지식을 SW 설계와 제작에 응용하는 것이며 이를 개발, 운용, 유지보수에 필요한 문서 작성과정
        
    제품을 단지 생산하는 것이 아닌 가장 경제적 방법으로 양질의 제품을 생산하는 방안
    계층화 기술 사용

---

# 계층화 기술
    도구, 방법, 절차
- 도구 : Tool
    - 절차와 방법을 자동 or 반자동 처리 기능 제공, 대표적 CASE 사용
- 방법 : Method
    - SW 구축의 기술적 방법 제공
- 절차 : Process
	- SW 개발에 사용되는 개발 방법과 도구의 사용 순서
     
> 계층화 기술들을 결합시켜 합리적이고 적절한 방법으로 SW 개발 및 유지

--- 

# 기본 원칙
- 지속적 현대적 프로그래밍 기술 적용
- 개발된 SW 품질 유지를 위한 지속적 검증
- SW 개발 관련 사항 및 결과의 명확한 기록 유지

# 발전 과정
- 1960 : SW 공학 시작, 구조적 프로그래밍
- 1970 : 구조적 분석/설계 개념 도입, 상품화
- 1980 : 하드웨어 가격 하락
- 1985 ~ : 객체지향 기술, CASE 등의 활용, 재공학

---

# 품질과 생산성
	품질, 생산성

---

### 품질
- 사용자 요구 동작 구현
- 효율적 하드웨어 자원 이용
- 일정 시간 내에 주어진 조건 하에서 원하는 기능 실행
- 처리 절차 기반 정확한 결과 산출
- SW 개발, 유지보수 등 초기 예상 비용 이내 수행
- 사용편리성을 위한 사용자 인터페이스 제공
- 유지보수 용이, 높은 신뢰성 제공
- 에러 최소화
- SW 사용법, 구조 설명, 성능, 기능 이해용이성 필요
- 빠른 실행 속도, 적은 기억 용량 사용

---

### 생산성
        투입된 비용과 노력에 대한 생산량
        
- 개발자 능력
- 원활한 의사 소통
- 프로젝트 복잡도와 성격
- 기술 수준
- 관리 기술

---

# SW 생명 주기
- SW 수명 주기
- SW 개발 방법론 바탕
- SW 개발을 위해 정의하고 운용/유지보수 등의 과정을 단계별 분할
- 프로젝트 비용 산정과 개발 계획 수립을 위한 기본 골격
- 프로젝트 진행 방향 명확화
- 용어 및 기술의 표준화
- 프로젝트 관리 용이
- 여러 SW 간 상호 일관성 유지

---

# SW 단계
    정의 단계, 개발단계, 유지보수 단계

---

### 정의 단계
- SW 개발 여부 정의하는 단계
- 관리자와 사용자가 가장 많이 참여하는 단계
- 타당성 검토 > 개발 계획 > 요구사항 분석

---

### 개발 단계
	실제적 SW 개발 단계
- 설계 단계   : 구조, 알고리즘, 자료구조 작성 단계, 에러 가장 많이 발생
- 구현 단계   : 설계 문서 기반 코딩, 번역 단계
- 테스트 단계 : 구현 SW에 내재된 오류 발견 단계

---

### 유지보수 단계
	SW 적응 및 유지 단계
	SW 생명 주기 단계 중 가장 높은 비율의 시간과 비용 발생
	정의   : 개발 계획, 요구사항 분석
	설계   : 구조, 알고리즘
	구현   : 코딩
	테스트 : 오류 검출

---

# 생명 주기 모형
    폭포수 모형, 프로토타입 모형, 나선형 모형, 4GT 모형
    
---

### 폭포수 모형
- SW 개발 각 단계를 완료하고 그 결과를 철저히 검토/승인 후 다음 단계 진행
- 이전 단계로 넘어갈 수 없는 가장 오래되고 폭넓게 사용된 전통적인 생명 주기 모형
- 선형 순차적 모형: 선행 단계 완료 후 다음 단계 진행
- 많은 성공 사례
- 단계별 정의 명확, 전체 공조 이해 용이
- 단계별 산출물 정확 => 공정의 기준점 제시
- 개발 중 신규 요구 반영 어려워, 초기 모든 요구사항 명확화 필요
- 오류 없이 다음 단계 진행은 현실적으로 불가능
- 업무 운용 시 미검출 오류 발생 가능
- 타당성 검토 > 계획 > 요구분석 > 설계 > 구현(코딩) > 테스트(검사) > 유지보수

---

### 프로토타입 모형
- 사용자 요구사항을 정확하게 파악하기 위해 시제품을 만들어 최종 결과물을 예측하는 모형
- 시제품은 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발
- 폭포수 모형 단점 보완
- 프로토타입은 "요구 분석 단계"에서 사용
- SW 생명주기에 유지보수가 없어지고, 개발 단계 내에 유지 보수 진행
- 요구사항 변경 용이
- 최종 결과물 제공 전 최종 결과물의 일부 또는 모형 제공
- 사용자와 개발자에게 공통 참조 모델 제공
- 실제 SW와 차이 발생 가능
- 단기간 제작을 위해 비효율적 언어 및 알고리즘 사용 가능
- 요구 수집 > 빠른 설계 > 프로토타입 구축 > 고객 평가 > 프로토타입 수정 > 구현

---

### 나선형 모형
- Boehm 제안, 폭포수와 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형
- 반복적 개발 과정을 통해 점진적으로 완벽한 최종 SW 개발
- 점진적 모형
- SW 개발 시 발생하는 위험을 관리하고 최소화 목적
- Planning => Risk Analysis => Engineering => Customer Evalutation
- 가장 현실적 모형
- 대규모 프로젝트나 큰 시스템에 적합
- 개발 과정 반복으로 누락되거나 추가된 요구사항 구현 가능, 정밀하며 유지보수 불필요
- 위험성 관리 실패 시 문제 발생
- 계획 및 정의 > 위험 분석 > 공학적 개발 > 고객평가의 반복

---

### 4GT 모형
- 사용자와 개발자 쉽게 접근, 4G 언어, 요구사항 명세서로부터 원시코드 자동생성 모형
- 설계 단계 축소, 요구 분석단계에서 코딩단계로 전환 가능한 비절차적 모형
- 중소형 SW 개발 시간 절감,  대규모에는 자동화로 인해 분석/설계 단계에 많은 시간 필요
- 요구사항 수집 > 설계 전략 > 4GL 구현 > 제품화

---

# 프로젝트 관리
    주어진 기간 내에 최소 비용으로 사용자 요구를 만족시키는 시스템을 개발하기 위한 활동
    SW 개발 계획을 세우고 분석, 설계, 구현 등 작업을 통제하는 것
    SW 생명 주기 전 과정에 걸쳐 진행

---

### 프로젝트 관리 대상
- 계획관리 : 프로젝트 계획, 비용산정, 일정 계획, 조직 계획
- 품질관리
- 위험관리

---

### 프로젝트 3대 요소
- People  : 인적자원
- Problem : 사용자 관점 문제 분석 및 인식
- Process : SW 개발을 위한 전체적 작업 계획 및 구조

---

### 프로젝트 구성 단계
- 프로젝트 계획 수립
- 프로젝트 실행
- 프로젝트 통제
- 프로젝트 종료

---

### 프로젝트 계획 수립
- 프로젝트 수행 전 SW 개발 범위, 비용, 일정, 자원 등의 예측 작업
- 관리자가 합리적으로 예측할 수 있도록 프레임워크 제공
- SW 개발 과정 내 발생 가능 위험성 최소화
- 계획 수립 후 시스템 정의서와 프로젝트 계획서 산출
- 프로젝트 관리자 임무
- SW 개발 영역 결정(범위)
	- 프로젝트 계획 수립 첫 단계
	- 개발될 SW 영역 결정
	- 주요 요소 : 처리 데이터, SW 기능, 성능, 제약 조건, 신뢰도, 인터페이스 등
	- 인터페이스
		- SW에 의해 간접적으로 제어되는 장치와 소프트웨어를 실행하는 프로세서나 하드웨어
		- 운영체제, 서브루틴 패키지와 같이 신규 SW에 연결되는 SW
		- 키보드나 기타 I/O 장치를 통해 SW를 사용하는 사람
		- 순서적인 연산에 의해 SW를 실행하는 절차
- 자원 추산
	- SW 개발 필요자원 예측
	- 인적자원, 재사용 SW자원, 환경 자원
- SW 프로젝트 추산
	- 프로젝트 수행 비용 예측 활동
- 프로젝트 계획 수립시 고려사항
	- 프로젝트 복잡도, 규모 - 가중치
	- 구조적 불확실성 정도
	- 과거 정보 가용성
	- 위험성

---

# SW 프로젝트 추산
	비용 예측 작업, 가장 어렵고 오차 발생이 심한 작업
- 프로젝트 비용 결정 요소
	- 프로젝트 요소
		- 제품 복잡도
		- 시스템 크기
		- 요구 신뢰도 : 일정한 기간 내에 주어진 조건 하에서 필요한 기능을 수행하는 정도
	- 자원 요소
		- 인적 자원 : 관리자/개발자 역량수준
		- HW 자원
		- SW 자원 : 개발 지원 도구
	- 생산성 요소
		- 개발자 능력
		- 개발기간 단축

---

# 비용 산정 기법

---

### 하향식
- 전문가 판단 기법
	- 경험 많은 두 명 이상의 전문가에 의한 비용 산정 기법
	- 개인적, 주관적
	- 간편/신속 비용 산정
	- 의뢰자의 신뢰 획득 가능
- 델파이 기법
	- 전문가 판단 기법의 주관적 편견 보완 기법
	- 다수 전문가 의견 취합 선정하는 반복적 방법
	- 조정자: 1명, 전문가: 다수

---

### 상향식
	프로젝트 세부작업 단위별 비용 산정 후 집계하여 전체 비용 산정 방법
- LOC 기법
	- 원시 코드 라인수 기법
	- SW 각 기능의 원시 코드 라인 수, 비관치, 낙관치, 기대치를 측정하여 예측치 산출 후 비용을 산정하는 기법
	- 측정 및 이해 용이, 많이 사용
	- 예측치    = (낙관치 + (4 X 기대치) + 비관치) / 6 = (a + 4m + b) / 6
	- ManMonth  = 개발 기간 X 투입 인원 = LOC / 1인당 월평균 코딩량
	- 개발 비용 = ManMonth X 1인 인건비
	- 개발 기간 = ManMonth / 투입 인원
	- 생산성    = LOC / ManMonth
- 개발 단계별 노력(인원수) 기법
	- Effort Per Task
	- 각 기능 구현 시 필요한 ManMonth를 생명 주기의 각 단계별로 산정
	- LOC보다 정확

---

### 수학적 산정 기법
        상향식 비용 산정 기법
        경험적 추정 모형 = 실험적 추정 모형
        COCOMO, Putnam, FP 모형
- COCOMO 모형
	- COnstructive COst MOdel
	- Boehm 제안
	- 원시 프로그램 규모인 LOC에 의한 비용 산정 기법
	- 개발 SW의 규모 예측 후 SW 종류에 따라 비용 산정 방정식을 적용하여 비용 산출
	- 비용 견적의 강도 분석 및 유연성이 높아 널리 사용
	- 같은 규모의 SW도 성격에 따라 다른 비용 산정
	- 비용 산정 결과는 ManMonth로 표현
	- COCOMO 유형
		- 조직형 (Organic Mode)
			- 중소규모, 5만 라인 이하 SW 개발
			- 사무처리, 업무, 과학용 응용 SW 개발 적합
		- 반분리형 (Semi-Detached Mode)
			- 30만 라인 이하 SW 개발
			- 트랜잭션 처리 시스템, 운영체제, DBMS, 컴파일러, 인터프리터 등 유틸리티 개발 적합
		- 내장형 (Embedded Mode)
			- 30만 라인 이상 SW 개발
			- 대규모 트랜잭션 처리 시스템, 운영체제, 신호기 제어, 미사일 유도
            - 실시간 처리 등 시스템 프로그램 개발 적합
	- COCOMO 종류
		- Basic        : 기본형, SW 크기와 개발유형만 이용
		- Intermediate : 중간형
            - 기본 COCOMO 사용하나 제품, 컴퓨터, 개발요원, 프로젝트 특성 기반 비용 산정
		- Detail       : 발전형
            - 개발 공정별 상세하고 정확하게 노력을 산출하여 비용을 산정하는 모형
            - SW 환경 및 구성요소가 사전 정의되어 있어야하고 개발과정 후반부에 주로 적용
- Putnam 모형
	- Putnam 제안
	- 생명 주기 예측 모형
	- 시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선 기반 노력 분포도를 기초하여 예측
	- SLIM : Rayleigh-Norden 곡선과 Putnam 예측 모델 기반의 자동화 추정 도구
- FP 모형
	- 기능 점수 = Function Point
	- Albrecht 제안
	- SW 기능 증대 요인별 가중치 부여 후 영향도를 적용하여 계산한 기능점수 기반 비용 산정 기법
	- 높은 유용성/간편성으로 비용 산정 기법 가운데 최선의 평가
	- ESTIMACS : FP 모형 기반 자동화 추정 도구

---

# 프로젝트 일정 계획
- 프로젝트 프로세스를 이루는 소작업의 순서와 일정을 정하는 활동 
- SW 개발의 일정 지연 방지 및 계획대로 진행되도록 일정을 계획
- 계획된 일정은 프로젝트 진행 관리의 기초 자료
- 계획된 일정과 프로젝트의 진행도를 비교하여 차질이 있을 경우 조정 가능
- WBS, PERT/CPM, Gantt Chart

---

### 사람-노력 관계
- 소규모 개발 프로젝트: 한 사람이 요구사항 분석, 설계, 코딩, 테스트 가능
- 중/대규모 개발 프로젝트: 크기 증가할수록 더 많은 인력 참여 필요
- Brooks 법칙 : 프로젝트 중 신규 인력 투입은 작업 적응기간과 부작용으로 더욱 일정 지연

---

### 노력 분배
- 개발과정 내 노력 분배 규칙: 40-20-40 규칙 권장
- 분석/설계: 40, 코딩: 20, 테스트: 40

---

### WBS
- Work Breakdown Structure = 업무 분류 구조
- 개발 프로젝트를 여러 개의 작은 관리 단위로 분할하여 계층적으로 기술한 업무 구조

---

### PERT/CPM
- 프로젝트 지연 방지 및 계획대로 진행하기 위한 일정 계획 기법
- 초단시간 내 계획 완성위한 일정 계획 방법
- 프로젝트 개발 기간을 결정하는 임계 경로 제공(여유시간 = 0인 경로)
- 통계적 모델을 적용, 개별 작업에 대한 가장 근접한 시간을 측정하는 기준
- 개별 작업 시작시간 정의 및 작업들 간 경계 시간 계산
- 가장 빠른 완료시간, 가장 늦은 완료시간, 총 자유시간 산출

---

### PERT
- Program Evaluation and Review Technique = 프로그램 평가 및 검토 기술
- 프로젝트 전체 작업의 상호 관계를 표시하는 네트워크
- 낙관적, 기대가능, 비관적 경우로 나누어 각 단계별 종료 시기 결정 방법
- 과거 경험이 없어 소요 기간 예측이 어려운 SW에 사용
- 노드와 간선으로 구성
    - 원 노드: 작업
    - 화살표 간선: 낙관치, 기대치, 비관치 표시
- 결정 경로, 작업 경계시간, 작업 간 상호관련성 식별 가능
- 작업 예측치 = (비관치 + (4 X 기대치) + 낙관치) / 6

---

### CPM
- Critical Path Method = 주공정 기법, 임계 경로 기법
- 프로젝트 완성을 위한 작업을 나열하고 작업에 필요한 소요 기간을 예측하기 위한 기법
- 노드와 간선으로 구성된 네트워크
    - 노드: 작업
        - 원형 노드: 작업과 소요기간 표시
        - 박스 노드: 이정표, 예상 완료 시간 표시
    - 간선: 작업 간 전후 의존 관계 표시
- 전 작업 완료 후 다음 작업 진행 가능
- 각 작업의 순서와 의존관계, 작업의 동시성을 한 눈에 파악 가능
- 프로젝트 규모 추정 > 단계별 작업 분할 > 작업 간 관계 > CPM 네트워크 => 일정 계획 > 간트 차트

---

### Gantt Chart
- 간트 차트 = 시간선 = Time Line
- 프로젝트 각 작업들의 시작과 종료 일정을 막대 도표를 이용하여 표시하는 프로젝트 일정표
- 중간 목표 미달성시 그 이유와 기간 예측 가능
- 자원 배치, 인원 계획 수립 가능
- 다양한 형태 변경 가능
- 작업 경로 표시 불가능
- 약한 계획 변화 적응성
- 계획 수립 및 수정 시 주관적 편향가능
- 구성: 이정표, 작업일정, 작업기간, 산출물, 작업자

---

# 프로젝트 조직 구성 계획

---

### 분산형 팀 구성
- 팀원 전체 의사 결정 참여 방식의 협력적 구성
- 민주주의식 팀 구성, 링 구조
- 팀 구성원 참여도, 만족도 향상 및 이직률 저하
- 팀 구성원 각자 서로의 일을 검토하고 결과에 대해 같은 그룹의 일원으로 공동 책임
- 여러 사람의 의사를 교류 => 복잡하고 난해한 문제 해결을 위한 프로젝트 적합
- 팀 구성 방법 중 가장 많은 의사 소통 경로를 갖는다.

---

### 중앙 집중형 팀 구성
- 관리자 의사 결정에 의한 진행 방식
- 관리자(책임 프로그래머)  팀 구성
- 프로젝트 수행의 모든 권한과 책임을 한 명의 관리자에게 위임
- 소규모 프로젝트에 적합
- 프로젝트 성공은 관리자 역량에 좌우
- 관리자 의사 결정 기반 빠른 의사 결정 및 의사 소통 경로 감소
- 책임 프로그래머 : 요구 분석 및 설계, 기술적 판단, 프로그래머 작업 지시 및 배분
- 프로그래머      : 책임 프로그래머 지시에 따른 코딩, 테스트, 디버깅, 문서 작성
- 프로그램 사서   : 프로그램 리스트, 설계 문서, 테스트 계획 관리
- 보조 프로그래머 : 책임 프로그래머의 업무 지원, 책임 프로그래머 감독 하 분석/설계/구현 담당

---

### 계층적 팀 구성
- 분산형과 중앙 집중형 혼합 형태 구성
- 초급 프로그래머를 작은 그룹으로 만들어 각 그룹을 고급 프로그래머가 관리
- 기술 인력이 관리를 담당하게 되어 좋은 기술력을 사장 우려
- 기술 인력의 업무 관리 능력 필요

---

# SW 품질 보증

---

### 품질 표준
	SW 운영특성, 변경 수용 능력, 환경 적응 능력에 따라 분류
- 운영특성
	- 정확성     : Correctness, 사용자 요구 기능 충족
	- 신뢰성     : Reliability, 요구 기능을 오류 없이 수행하는 정도
	- 효율성     : Efficiency, 자원을 낭비하지 않는 정도
	- 무결성     : Integrity, 허용되지 않는 사용이나 자료 변경을 제어하는 정도
	- 사용용이성 : Usability, 적절한 UI와 문서 제공
- 변경 수용 능력
	- 유지보수성 : Maintainability 변경 및 오류 교정에 대한 노력을 최소화 하는 정도, SW 진화 가능
	- 유연성     : Flexibility 수정 용이한 정도
	- 시험 역량  : Testability 시험 용이한 정도
- 적응 능력
	- 이식성      : Portability 다양한 HW 환경 운용을 위한 수정 가능 정도
	- 재사용성    : Reusability 전체나 일부를 다른 목적으로 사용할 수 정도
	- 상호 운용성 : Interoperability 다른 SW와 정보를 교환할 수 있는 정도

---

### 품질 보증
	- SQA = Software Quality Assurance
	- 요구사항 일치 여부를 확인데 필요한 개발 단계 전체에 걸친 계획적이고 체계적인 작업
    - 단계:
        - 개발 초기: SW 특성과 요구사항 철저히 파악, 품질 목표 설정
        - 개발 단계: 정형 기술 검토 기반 품질 목표 충족 여부 점검
        - 개발 이후: 디버깅 및 시험

---

### 정형 기술 검토
- FTR = Formal Technical Review
- 가장 일반적 검토 방법으로 SW 개발자들에 의해 수행되는 SW 품질 보증 활동
- 검토회의, 검열 등의 회의 형태
- 요구사항 일치 여부 검증, 표준준수 확인, 기능 및 로직 오류 확인
- 균일한 방식의 개발 적용 가능, 프로젝트 관리 용이
- 정형 기술 검토 지침사항
	- 제품 검토에만 집중
	- 의제를 제한하여 진행
	- 논쟁과 반박을 제한
	- 문제영역을 명확히 표현
	- 해결책/개선책은 논의 제외
	- 참가자 제한 및 사전 준비 강요
	- 검토될 확률이 있는 각 제품에 대한 체크리스트 개발
	- 자원과 시간 일정 할당
	- 모든 검토자들을 위해 훈련
	- 사전 정보 공유
	- 검토 과정과 결과 재검토
- 정형 기술 검토 유형
	- Walkthrough
		- 검토회의
		- SW 개발 각 단계 기술 평가 회의
		- SW 구성요소와 같은 작은 단위 검토 활동
		- 오류 조기 검출 목적, 발견된 오류 문서화
		- 검출된 오류는 회의 후에 해결
		- 3~5명 검토 참여, 두 시간 이내
		- 검토 자료 미리 배포하여 검토, 미리 검토하는 시간도 두 시간 이내
	- Inspections
		- 검열, 심사
		- 검토회의(Walkthrough) 발전 형태
		- SW 개발 단계 결과물의 품질을 평가하고 이를 개선하기위한 활동 
	- 기타
		- 검증      : Verification 설계 과정 검토, SW/HW 오류 존재 검사
		- 확인      : Validation 올바른 제품 생산을 정의, 분석 결과 검사
		- 인증      : Certification 사용자 또는 전문가의 공식적 SW 품질 확인
		- SW 시험   : Test
		- 오류 수정 : Debugging

---

# SW 신뢰성과 가용성
    신뢰성 : 프로그램이 주어진 환경에서 주어진 시간동안 오류없이 작동할 확률(측정/예측 가능)
    가용성 : 프로그램이 주어진 시점에서 요구사항에 따라 운영되는 확률

---

### 측정
	신뢰성 측정: MTBF
- MTBF
	- Mean Time Between Failure
	- 평균 고장 간격
	- 수리 가능한 시스템이 고장난 후부터 다음 고장까지의 평균 시간
	- MTBF = MTTF + MTTR
- MTTF
	- Mean Time To Failure
	- 평균 가동 시간 = 고장 평균 시간
	- 수리 불가능한 시스템의 사용 시점부터 고장이 발생할 때까지의 평균 가동 시간
	- MTTF = (가동시간1 + 가동시간2 + 가동시간3 + ... + 가동시간n) / n
- MTTR
	- Mean Time To Repair
	- 평균 수리 시간
	- 시스템 고장이 발생하여 가동하지 못한 평균 시간
	- MTTR = (고장시간1 + 고장시간2 + 고장시간3 + ... + 고장시간n) / n
- 가용성 측정
	- 시스템 총 운용 시간 중 정상적 가동 시간의 비율
	- 가용성 = 가동시간 / (가동시간 + 고장시간) = MTBF / (MTBF + MTTR)

---

# 위험 관리
    Risk Analysis
    프로젝트 진행 중 예상되는 각종 돌발 상황을 식별하고 대책을 수립하는 활동
    위험의 불확실성과 손실 발생에 대비하기 위해 위험관리 수행
    위험 식별 > 위험 분석 및 평가 > 위험 관리 계획 > 위험 감시 및 대응

---

### 위험범주
- 프로젝트 위험
- 기술 위험
- 비즈니스 위험

---

### 위험종류
- 인력 부족
- 예산 부족, 초과
- 일정 지연
- 요구사항 변경 : 대표적 위험 요소

---

### Charette 제안 위험 종류
- 알려진 위험        : 프로젝트 계획서, 기술적 환경, 정보 등 발견 가능한 위험
- 예측 가능한 위험   : 과거 경험 기반 예측 가능 위험
- 예측 불가능한 위험 : 사전 예측 어려운 위험

---

### 위험 분석 및 평가
- 프로젝트에 내재한 위험 요소를 인식하고 그 영향을 분석하는 활동
- 위험 추산(Risk Estimation)으로 수행
- 가능한 모든 위험 요소와 영향을 분석하고 의사결정에 반영
- 위험표(Risk Table) 작성 및 활용
	- 위험표
		- 위험 내용
		- 위험 범주
		- 발생 확률
		- 영향력
		- 위험 감시 및 대응

---

### 위험 감시 및 조치
- 위험 회피 : 예상하고 회피
- 위험 감시 : 위험 요소 징후의 지속적 인지
- 위험 관리 : 수용가능한 범위 내 완화, 수용 활동
- 비상 계획 수립 : (Contingency Plan) 위험 대응 전략 실패 시 대비책과 비상계획 수립

---

# SW 형상 관리
- SCM = Software Configuration Management
- SW 변경 사항 관리위해 개발된 일련의 활동
- SW 변경 원인 식별 및 제어, 변경 확인 및 기록
- SW 개발 전체 단계 적용, 유지보수 단계 적용
- SW 개발 전체 비용 절감, 개발 과정 방해 요인 최소화
- 형상: SW 각 개발 단계별 결과물

---

### SW 형상 항목
- SCI = Software Configuration Item
- 시스템 명세서, 프로젝트 계획서, 요구사항 명세, 프로토타입, 사용자 매뉴얼
- 설계 명세서, 원시 코드 목록
- 테스트 계획, 절차, 시험 사례, 결과
- 실행 프로그램
- 운영과 설치 매뉴얼
- DB 기술서(스키마, 파일 구조, 초기 내용)
- 유지보수 문서(변경 요청서, 변경 처리 보고서)
- SW 공학 표준과 절차

---

### SW 형상 관리 기능
- 형상 식별 : 대상의 이름 및 관리번호 부여, 계층(트리)구조
- 버전 제어 : 버전 제어 시스템 기반 SW나 문서의 변경 사항을 추적 관리
- 변경 제어 : 형상 항목의 변경 요구를 검토해 변경 기준선을 통제하는 활동
- 형상 감사 : 기준선의 무결성을 평가
- 형상 기록 : 상태 보고

---

# 전통적 SW 개발 방법
    고전적 SW 개발 방법,  구조적 SW 개발 방법
    SW 개발 경험을 토대로 성공적으로 평가되는 SW 분석 및 설계 방법들을 
    집대성하여 정형화한 개발 방법

---

### 요구사항 분석
- 사용자 요구사항 이해 및 문서화 활동
- 요구 타당성 조사, 비용과 일정 제약 설정
- 요구 추출, 목표 설정, 해결 방식 결정
- 요구사항 분석 결과는 설계단계 입력 자료
- 정확성, 일관성, 문서화
- SW 분석가 수행

---

### 요구사항 분석작업
- 문제 인식      : 사용자 면담, 설문조사 및 협조, 문서 검토
- 평가 및 종합   : 요구사항 정보 평가 및 해결책 종합
- 모델 제작      : 요구 내용 이해위한 모델 작성
- 문서화 및 검토 : 요구사항 분석 명세서 작성

---

### 요구사항 분석의 어려움
- 대화 장벽          : 다이어그램 및 프로토타입 이용
- 시스템 복잡도      : 구조적 분석 or 객체지향 분석 이용
- 요구 변경          : 수정 요구와 상반된 요구들의 수용 기술 필요
- 요구 명세화 어려움 : 제도적 요구 분석 기술 필요, 절차/도구/기법 제도화

---

### 분석가의 자질
- 개발 경험 풍부
- 정확한 요구 수용 및 환경 이해
- 출분한 분석자료의 설계 단계 전달
- 효율적 시간 배정, 빠른 시간 내 계획 파악
- HW/SW 기술 이해
- 고객 관점 문제 파악

---

### 구조적 분석 기법
- 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법
- 도형 중심의 도구 사용으로 분석가와 사용자 간 대화 용이
- 하향식 방법 사용으로 시스템을 세분화하고 분석의 중복을 배제
- 자료흐름도, 자료사전, 소단위 명세서, 개체 관계도, 상태 전이도, 제어 명세서

---

### 구조적 분석 도구
    자료흐름도, 자료사전, mini spec, 개체관계도, 상태전이도, CASE, HIPO
    HIPO chart, 가시적/총체적/세부적 도표
    
- 자료 흐름도
	- DFD = Data Flow Diagram = 자료 흐름 그래프 = 버블 차트
	- 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법
	- 시스템 내 프로세스와 자료저장소 사이의 자료 흐름을 표현하는 그래프
	- 자료흐름 및 처리 중심 구조적 분석 기법
	- 자료흐름 및 기능의 상세 표현위해 단계적 세분화
	- 자료는 처리/변환마다 새로운 이름 부여
	- 처리(프로세스): 입력자료에 기능 수행 후 출력자료 산출
	- 자료 흐름도를 세분화할수록 SW 설계 및 구현 용이
	- 자료 흐름도 구성요소
		- 프로세스
			- 자료를 변환시키는 시스템의 한 부분
			- 처리 = 기능 = 변환 = 버블
			- 원/둥근 사각형 표시, 프로세스 이름 표기
		- 자료 흐름(Data Flow)
			- 자료 흐름 or 연관관계 표현
			- 화살표 위 자료 이름 표기
		- 자료 저장소(Data Store)
			- 파일, 데이터베이스
			- 도형 안 자료 저장소 이름 표기
		- 단말(Terminator)
			- 시스템과 교신하는 외부 개체
			- 입력 데이터 생성, 출력 데이터 획득
			- 정보의 생산자 및 소비자
- 자료 사전
	- DD(Data Dictionary), 데이터의 데이터, Meta Data
	- 자료 흐름도 상의 자료를 더 상세히 정의/기록한 것
	- 자료 사전 기호
		- =     : 자료 정의, is composed of
        - --    : 자료 연결, and
		- ( )   : 자료 생략, optional
		- [ | ] : 자료 선택, or
		- { }   : 자료 반복, Iteration of
		- * *   : 자료 설명, comment
- 소단위 명세서
	- Mini Specification, 프로세스 명세서
	- 세분화된 자료 흐름도에서 최하위 단계 프로세스의 처리 절차를 기술
	- 분석가의 문서
	- 자료 흐름도 지원위해 작성
	- 서술문장, 구조적언어, 의사결정나무, 의사결정표, 그래프 등 이용해서 기술
- 개체 관계도
	- ERD(Entity Relationship Diagram)
	- 시스템에서 처리되는 개체와 개체의 구성과 속성, 개체 간의 관계를 표현하여 자료를 모델화
	- Entity, Attribute, Relationship
- 상태 전이도
	- STD(State Transition Diagram)
	- 시스템 이벤트 발생 시 시스템의 상태와 상태 간 전이를 모델화
	- 상태 전이도를 통해 시스템 행위 정의 가능
- CASE
	- 요구사항 분석위한 자동화 도구
	- SADT    : Structured Analysis and Design Technique
        - 다양한 도구를 사용하여 시스템의 요구사항, 기능, 프로세스, 데이터 흐름 등을 모델링
	- SREM    : Software Requirements Engineering Methodology = RSL/REVS
        - 요구사항 도출, 분석, 명세, 검증, 유지보수하기 위한 일련의 프로세스 제공
        - RSL (Requirements Specification Language)
            - 요구사항 명세 작성 언어, 일관성 있게 기술, 추적 가능
        - REVS (Requirements Engineering Verification and Validation System)
            - 요구공학 검증 및 검토 도구
            - 요구사항 완전성과 일관성 기술 여부, 시스템 요구사항 충족, 요구사항 변경여부 등 검증
            - 요구사항 명세서 품질 향상
	- PSL/PSA : Problem Statement Language / Problem Statement Analyzer
        - PSL: 시스템개발 문제점 기술언어, 문제점을 정확/일관된 명세 제공, 요구분석과 설계 지원
        - PSA: PSL 문서분석 후 문제점, 요구사항, 제약조건 등 식별 및 요구명세 자동 도출
	- TAGS    : Technology for Automated Generation of Systems
        - 요구사항 표현 형식 언어와, 이를 기반으로 시스템을 생성하는 모델 기반 생성 기술 구성
- HIPO
	- Hierarchy Input Process Output
	- 시스템의 분석 및 설계나 문서화를 위한 구조적 분석 기법
	- 시스템의 입력, 처리, 출력을 계층적 구조로 분해하여 분석하는 기법
	- 하향식 SW 개발을 위한 문서화 도구
	- 기호, 도표 기반 이해 용이
	- 기능과 자료의 의존 관계 동시 표현
	- 변경, 유지보수 용이
    - 3계층
        - 상위계층: 시스템 목적 및 전반적 구조
        - 중간계층: 시스템 기능을 입력, 처리, 출력으로 분할하여 분석
        - 하위계층: 입력, 처리, 출력 상세 분해 및 기능 정의
- HIPO Chart
	- 시스템 기능을 여러 개의 고유모듈로 분할하여 이들 간의 인터페이스를 계층 구조로 표현
	- 가시적 도표, 총체적 도표, 세부적 도표
- 가시적 도표
	- 도식 목차(Visual Table of Contents)
	- 전체 시스템인 기능과 흐름을 표현하는 트리 구조도
- 총체적 도표
	- 총괄 도표, 개요 도표, Overview Diagram
	- 프로그램 구성기능 기술
	- 입력, 출력, 처리에 대한 전반적 정보 제공
- 세부적 도표
	- 상세 도표(Detail Diagram)
	- 총체적 도표에 표시된 기능을 구성하는 기본 요소들의 상세 기술 도표

---

### SW 설계
- 구조적 분석 결과물 기반 SW 기능과 구조, 모듈 설계전략, 평가지침, 문서화 도구를 제공하는 체계화된 기법
- 자료 흐름 중심 설계 기법
- 설계 모형: 데이터 설계, 구조 설계, 인터페이스 설계, 프로시저 설계
	- 데이터 설계(Data Design)
		- 요구 분석 단계에서 생성된 정보를 SW 구현에 필요한 자료 구조로 변환
		- 입력: ERD 기반 개체관계, 자료 사전의 자료 정보 등
	- 구조 설계(Architectural Design)
		- SW 구성모듈 간의 관계 및 프로그램 구조 정의
		- 입력: DFD, DD, STD 등과 모듈 상호 작용
	- 인터페이스 설계(Interface Design)
		- SW와 상호작용하는 시스템, 사용자 등과 통신 방법 기술
		- 입력: DFD 등
	- 프로시저 설계(Procedural Design)
		- 모듈 기능 절차 설계
		- 입력: 소단위 명세서, 상태 전이도
- 기타 분류
	- 사용 관점
		- 내부 설계 : 시스템 내부 조직과 세부절차 개념화 및 명세화
		- 외부 설계 : 시스템 외부 특성 명세화
	- 관리적 관점
		- 기본 설계 : 요구분석에서 생성된 정보를 자료구조와 SW구조로 변환
		- 상세 설계 : 기본설계 사항을 구체적 자료구조와 알고리즘으로 표현
- 설계 기본 원리
	- 모듈화(Modularity)
		- 모듈 단위 구현
	- 추상화(Abstraction),개념화
		- 문제의 전체적/포괄적 개념을 설계한 후 세분화/구체화하는 설계 방법
		- 기능 추상화 : 입력의 출력 변환 과정 추상화
		- 자료 추상화 : 자료와 자료에 적용되는 기능을 함께 정의함으로써 자료객체 구성
		- 제어 추상화 : 제어의 정확한 메커니즘을 정의하지 않고 원하는 효과를 정의하는 방법
    - 계층화(Layering)
        - 복잡한 시스템의 계층적 분할 설계
        - 각 계층은 연결된 계층만 영향, 상위계층은 하위계층 기능 이용 가능
    - 분할과 정복(Divide and Conquer): 복잡한 문제를 작은 부분으로 나누어서 해결하는 방법론
        - 분할(Divide)  : 문제를 작은 부분으로 분할
        - 정복(Conquer) : 작은 부분으로 나눈 문제를 해결
        - 통합(Combine) : 해결된 작은 부분들을 통합
	- 단계적 정제(Stepwise Refinement)
		- 문제를 중요개념에서 하위개념으로 구체화
	- 정보 은닉(Information Hiding)
		- 한 모듈 내부 절차와 자료 정보를 숨겨 다른 모듈의 접근/변경을 제어하는 기법
		- 모듈의 독립적 수행, 모듈 변경 영향 전파 최소화 => 수정, 시험, 유지보수 용이성 향상
    - 모듈 결합(Coupling)와 응집도(Cohesion)
        - 결합: 모듈 간 상호작용 강도
        - 응집: 모듈 내부 기능관련성 정도
        - 결합도 최소화, 응집도 최대화 => 유지보수성, 확장성 향상
    - 단순성(Simplicity)
        - 가능한 한 간단하게 구현 중요
        - 복잡한 구현은 오류 발생 확률 증가, 유지보수성 저하
    - 유연성(Flexibility)
        - 변화 대처 능력 중요
        - 예상치 못한 변경에 대한  대처 수용 - 모듈화, 추상화 등
    - 재사용성(Reusability)
        - 기존 모듈/코드 재사용
        - 개발비용 절감, 개발시간 단축 - 모듈화, 인터페이스 설계 중요
    - 확장성(Scalability) : 시스템 증가나 변경 시 성능/기능 유지 - 모듈화, 분산 시스템 설계
    - 안정성(Reliability) : 예상못한 문제 대처, 오류 최소화 - 테스트, 예외 처리, 예방적 오류 수정
    - 보안성(Security)    : 시스템 내부 데이터 및 외부 통신 등에서 발생 가능한 보안 위협 대비
    - 성능(Performance)   : 처리 데이터 양이나 처리 속도 등에 대한 요구 충족
    - 가독성(Readability) : 코드 가독성 고려 - 유지보수성 향상, 오류 감소
    - 일관성(Consistency) : 일관성 있는 인터페이스 및 디자인 유지 - 사용자경험 향상, 유지보수성 향상
- 프로그램 구조(Program Structure), 제어 계층 구조
	- 모듈의 계층적 구성 표현
	- 일반적 트리 구조 다이어그램 표기
	- 공유도(Fan-In): 어떤 모듈을 제어(호출)하는 모듈 수
	- 제어도(Fan-Out): 어떤 모듈에 의해 제어(호출)되는 모듈 수
    - fan-in/fan-out: 
        - SW 설계 및 유지보수에서 모듈 간의 상호 작용 측정
        - 모듈의 복잡도와 결합도를 파악하여 개선할 수 있는 중요한 지표
	- 자료 구조
		- 자료 간 논리적 관계 표현
    - inside-out/outside-in: 소프트웨어 개발에서 설계 및 개발 방법론에 대한 관점
        - inside-out 방식:
            - SW 개발의 시작점을 구체적인 구현부터 시작하는 방식
            - 구체적인 구현부터 시작하여 전체적인 시스템 설계를 진행하는 방식
            - 구현 단계에서 발생하는 문제를 빠르게 파악하고 해결할 수 있는 장점
            - 시스템의 전체적인 구조를 고려하지 않고 개발이 진행될 가능성 존재
        - outside-in 방식:
            - SW 개발의 시작점을 시스템 기능과 사용자 요구 등 고수준 개념부터 시작하는 방식
            - 시스템의 전체적인 구조와 기능을 먼저 고민하고 이를 세부적인 구현으로 전개하는 방식
            - 시스템 전체적인 목표를 고려하여 개발 가능
            - 구체적인 구현 단계에서 생기는 문제를 파악하는 데 어려움
- 좋은 설계
	- SW 구조 표현
	- 독립적 기능요소(모듈)로 구성
	- 특정 기능 or 부기능을 수행하는 논리적 요소들로 분리되는 구조
	- 모듈 간의 효과적 제어위해 계층적 자료구조 제시
	- 자료와 프로시저의 명확한 분리 표현 포함
	- 모듈 간 및 외부 개체 간 연결 복잡성 최소화 인터페이스
	- 요구 기반 반복적 방법 적용
	- 전체 요구 구현, 유지보수 용이
	- 예측가능한 모듈 기능 정의
	- 최적 모듈 크기 유지
	- 낮은 결합도, 높은 응집도
	- 전체적/포괄적 개념 설계 후 단계적 세분화/구체화 진행
	- 이식성 고려
- 모듈
	- 모듈화 : SW를 각 기능별로 분할하는 과정
    - 모듈   : 각 기능별로 분할한 구성단위
	- 기능적 독립성
		- 각 모듈의 기능 독립성
		- 모듈화, 추상화, 정보 은닉의 결과물
		- 모듈이 하나의 기능만 수행, 다른 모듈과 과도한 상호작용 배제
		- 독립된 모듈: 특정 기능 수행, 다른 모듈과 단순한 인터페이스 => 개발 용이,  재사용성 향상
		- 독립성 높은 모듈: 다른 모듈에 대한 변경 영향 최소화
		- 오류 발견 및 해결 용이
		- 측정: 결합도/응집도, 작은 모듈 크기 유지
		- 결합도 및 응집도: SW 설계 평가 지침
	- 결합도(Coupling)
		- 모듈 간 상호 의존 정도, 낮을수록 우수
		- 강한 결합도: 구현 및 유지보수 문제 발생 
		- 결합 정도:
			- 약함<======================================>강함
			- 자료 결합도 / 스탬프 / 제어 / 외부 / 공통 / 내용
			- 자료 결합도 - Data Coupling
				- 모듈 간 인터페이스가 자료 요소로만 구성
				- 모듈 호출 시 매개변수나 인수로 데이터 전달, 호출받은 모듈은 데이터 처리 결과 리턴
				- 모듈 내용 변경 시 다른 모듈에 전혀 영향이 없는 가장 좋은 결합도
			- 스탬프 결합도 - Stamp Coupling
				- 모듈 간 인터페이스가 배열/레코드 등의 자료구조 전달
				- 모듈 간 동일 자료 구조 조회 경우의 결합도
			- 제어 결합도 - Control Coupling
				- 모듈이 다른 모듈 내부의 논리적 흐름 제어위해 제어신호 이용/통신 및 제어요소 전달
				- 상위 모듈이 하위 모듈의 상세 처리 절차 파악하여 통제
                - 처리 기능이 두 모듈에 분리 설계된 경우 발생
				- 권리 전도현상 발생
			- 외부 결합도 - External Coupling
				- 모듈에서 외부로 선언한 데이터(변수)를 다른 모듈에서 참조
			- 공통 결합도 - Common Coupling, 공유 결합도
				- 공유되는 공통 데이터 영역을 여러 모듈이 사용
				- 공통 데이터 영역 내용 변경 시 연관된 모든 모듈에 영향 발생
			- 내용 결합도 - Content Coupling
				- 모듈이 다른 모듈의 내부 기능 및 내부 자료를 직접 참조/수정
				- 모듈에서 다른 모듈로 제어가 이동하는 경우도 내용 결합도
	- 응집도(Cohesion)
		- 정보 은닉 개념 확장
		- 명령어나 호출문 등 모듈 내부 요소들의 관련성 정도
		- 모듈의 기능 독립성 정보
		- 독립적 모듈: 강한 응집도 필요
		- 응집 정도:
			- 강함<=========================================================>약함
			- 기능적 응집도 / 순차적 / 통신적 / 절차적 / 시간적 / 논리적 / 우연적
			- 기능적 응집도 - Functional Cohesion
                - 모듈 내부의 모든 기능 요소들이 단일 문제와 연관
			- 순차적 응집도 - Sequential Cohesion
				- 모듈 출력 데이터를 다음 입력 데이터로 사용
			- 통신적 응집도 - Communication Cohesion
				- 동일한 입력과 출력 사용하는 서로 다른 기능 수행 구성요소들로 구성
			- 절차적 응집도 - Procedural Cohesion
				- 모듈이 다수의 관련 기능 수행 시 모듈 안의 구성요소들이 순차적 기능 수행
			- 시간적 응집도 - Temporal Cohesion
				- 특정 시간에 처리되는 다수의 기능을 모아 하나의 모듈로 작성
			- 논리적 응집도 - Logical Cohesion
				- 유사한 성격이나 특정 형태로 분류되는 처리 요소들로 하나의 모듈 형성
			- 우연적 응집도 - Coincidental Cohesion
				- 서로 관련 없는 요소로만 구성, 모듈 개념 상실
- 효과적 모듈 설계
	- 낮은 결합도, 높은 응집도 => 모듈 독립성 향상
	- 복잡도와 중복성을 줄이고 일관성을 유지
	- 예측 가능한 모듈 기능
	- 유지보수 용이
	- 모듈 크기: 시스템 전반적 기능과 구조를 이해하기 쉬운 크기로 분해
	- 하나의 입구와 하나의 출구
- 설계 방법
	- 데이터 설계(자료 설계)
		- 요구분석에서 생성된 여러 모델들을 자료 구조로 변환
	- 아키텍처 설계(구조 설계)
		- 프로그램 구조 개발, SW 구성 요소들 간 관계 정의
		- 구조 도표 : 
            - SW 기능을 몇 개의 고유 기능으로 분할하여 블랙 박스 표현
            - 블랙 박스 간의 인터페이스를 계층 구조로 표현
		- 변환 분해 접근법 : DFD를 흐름에 따라 구분하여 프로그램 구조 도표로 변환하는 방법
		- 거래 분해 접근법 : 거래 부분을 중심으로 DFD를 거래 중심 구조 도표로 변환하는 방법
	- 구조적 설계 절차
		- 정보 흐름 유형 설정, 흐름 경계 표시
		- 자료 흐름도를 프로그램 구조로 사상
		- 제어 계층 분해하여 정의
		- 경험적 방법 기반 구체화
	- 인터페이스 설계
		- SW와 상호작용하는 시스템, 사용자 등과의 통신 방식 기술
		- 인터페이스 경고 메세지 지침
			- 이해 용이한 메세지 내용
			- 오류 회복을 위한 구체적 설명 제공
			- 소리/색 등 이용하여 의미 전달 향상
		- UI 평가 기준
			- 사용용이성/이해용이성, 빠른 수행 속도
			- 사용중 오류 발생 빈도 최소화
			- 사용자 만족 충족
			- 쉬운 사용법
	- 프로시저 설계(절차 설계)
		- 데이터, 아키텍쳐, 인터페이스 설계 이후 설계 작업
		- 모듈 기능의 절차적 기술로 변환
		- 코드에 가까운 추상화 수준의 모듈 명세서 작성
		- 그래픽 설계 표기법, 프로그램 설계 언어 등 사용
		- 흐름도
			- 그래픽 설계 표기법
			- Flowchart
		- N-S Chart
			- 그래픽 설계 표기법, Nassi-Schneiderman Chart, 박스 다이어그램, Chapin Chart
			- 논리 기술 중점 도형 표현 방법
			- 박스를 기본 요소로 하여 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조 표현
			- GOTO, 화살표 사용안함
			- 복합 조건 처리를 시각적으로 명확히 식별하는 데 적합
			- 선택과 반복 구조를 시각적으로 표현
			- 이해하기 쉽고, 코드 변환이 용이
			- 읽기는 쉽지만 작성 난해
			- 임의 제어 전이 불가능
			- 총체적 구조 표현과 인터페이스 표현 문제 존재
			- 단일 입구, 단일 출구 표현
		- 프로그램 설계 언어(PDL, Program Design Language)
			- 영어 단어 이용 > 구조적 프로그래밍 제어 구조 기술
			- 하향식 접근 방식, 논리의 전체 흐름 표현
			- 사용자와 의사소통 용이
			- 현재 프로그래밍 언어와 유사한 서술적 표현 사용
            - 프로그램, 설계, 시스템 검토, 문서화 기법에 적용
		- 자료 구조 중심 설계
			- 요구분석 명세서를 토대로 입력과 출력 자료구조로부터 프로그램 구조와 세부절차 도출 방법
			- Jackson의 JSD, Warnier-Orr의 DSSD

---

### 구현
- 설계 단계의 설계문서를 컴퓨터가 알 수 있는 모습으로 변환하는 과정
- 프로그래밍 = 코딩
- 각 모듈을 프로그래밍 언어를 사용해 원시코드로 작성하고 문서화하는 작업
- 설계를 철저히 반영시키고 원시 코드를 간단 명료하게 작성
- 사용할 프로그램이 언어와 코딩 스타일 등을 결정 필요
 
- 프로그래밍 언어
	- 1세대 : 기계어, 어셈블리어
	- 2세대 : FORTRAN, ALGOL, COBOL, BASIC
	- 3세대 : PL/1, PASCAL, C, Lisp, C++
	- 4세대 : 
        - 비절차적 언어, 자연언어, 사용자 중심언어, 응용프로그램 생성기 언어
        - 프로토타입 언어, SQL, 정보 검색어, 보고서 작성기
- 구조적 프로그래밍
	- Dijkstra 제안
	- 신뢰성 있는 SW의 생산과 코딩의 표준화 등을 위해 개발
	- 순차, 선택, 반복 (Sequence, Selection, Iteration)

---

### 테스트(Test)
- 모듈 내 모든 독립적 경로를 적어도 한 번은 수행
- 가능한 복잡한 논리는 배제, 임의의 조건을 만족 필요
- 내부 자료 구조 기반 테스트 수행
- 화이트 박스 테스트
	- 모듈의 원시 코드의 논리적인 모든 경로를 검사하여 검사 사례를 설계하는 방법
	- 설계된 절차에 초점을 둔 구조적 테스트
	- 프로시저 설계의 제어 구조를 사용하여 검사 사례 설계
	- 테스트 과정 초기에 적용
	- 모듈 안 작동을 직접 관찰
	- 원시 코드의 모든 문장을 한 번 이상 수행
	- 논리 흐름도, 루프 구조, 순환 복잡도에 관한 오류 발견 가능
    - 기초 경로 검사, 제어 구조 검사(조건 검사, 루프 검사, 데이터 흐름 검사)
	- 기초 경로 검사(Basic Path Testing)
		- Tom McCabe 제안
		- 대표적 화이트 박스 테스트
		- 절차
			- 흐름도 작성
			- 논리적 복잡도 측정
			- 독립 경로들의 기초 집합 결정
			- 기초 집합의 각 경로를 실행시키는 검사 사례 선정
		- 제어 흐름도
			- 제어 흐름을 표현하기 위해 사용되는 그래프
			- 프로그램 그래프 = 흐름 그래프
			- 노드(원) : 절차적 명령문
			- 화살표   : 제어의 흐름
			- 영역     : 화살표와 노드로 둘러싸인 구역, 외부 구역도 하나의 영역에 포함
		- 순환 복잡도
			- 한 프로그램의 논리적 복잡도를 측정하기 위한 SW 척도
			- 제어 흐름도 이론에 기초
			- 순환복잡도는 제어 흐름도의 영역 수와 일치하므로 영역 수를 계산
			- 순환복잡도 = 화살표 수 - 노드 수 + 2
	- 제어 구조 검사
		- 조건 검사(Condition Testing)
			- 모듈 내 논리적 조건 검사 사례 설계 기법
		- 루프 검사(Loop Testing)
			- 반복 구조에 초점을 맞춰 실시하는 검사 사례 설계 기법
			- 초기화 오류, 인덱싱 증가 오류, 경계값 오류 등을 발견
		- 데이터 흐름 검사(Data Flow Testing)
			- 변수 정의 및 사용위치에 초점을 맞춰 실시하는 검사 사례 설계 기법
- 블랙 박스 테스트
	- SW 각 기능이 완전히 작동되는 것을 입증하는 검사, 기능 검사
	- SW 인터페이스에서 실시되는 검사
	- 테스트 과정 후반부에 적용
	- 적합한 입력에 대한 출력 정확성 점검
	- 동치분할, 경계값 분석, 원인효과 그래프 검사, 오류 예측 검사, 비교 검사
	- 동치분할 검사(Equivalence Partitioning Testing), 동등분할
		- 입력 조건에 타당한 입력자료와 타당하지 않은 입력 자료 수를 균등하게 하여 검사 사례 설계
        - 해당 입력 자료에 맞는 결과 출력 확인 방법
	- 경계값 분석(Boundary Value Analysis)
		- 입력 자료에 치중한 동치 분할 기법 보완
		- 입력 조건의 중간 값보다 경계값에서 오류가 발생될 확률이 높은 점 이용
		- 입력 조건의 경계값을 검사 사례로 선정
	- 원인효과 그래프 검사(Cause-Effect Graphing Testing)
		- 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석하여 효용성 높은 검사사례 선정
		- 그래프 표현
	- 오류 예측 검사(Fault Based Testing, Mutation Testing, 데이터 확인 검사)
		- 과거 경험이나 확인자 판단으로 검사
		- 보충적 검사 기법
	- 비교 검사(Comparison Testing)
		- 여러 버전의 프로그램에 동일 검사자료를 제공해 동일 결과 출력 여부 검사
- 검사 전략
	- 설계된 검사 사례를 수행하는 것
	- 단위 검사 : 프로그램 기본 단위인 모듈 수준에서 시작
	- 통합 검사 : 단위 검사 후 모듈을 결합하여 전체 시스템에 대해 검사
	- 검증 검사 : 사용자 요구 충족 검사
	- 시스템 검사 : 개발SW의 시스템에서 완변한 수행 여부 검사
- 단위 검사(Unit Test)
	- 코딩 후 모듈 대상으로 검사
	- 화이트박스 테스트 기법 사용
	- 인터페이스, 외부적 I/O, 자료구조, 독립적 기초 경로, 오류 처리경로, 경계 조건 등을 검사
- 통합 검사(Integration Test)
	- 단위 검사 완료 후 모듈을 통합하여 단일 시스템으로 완성시키는 과정에서의 검사
	- 모듈 간 인터페이스와 연관된 오류를 밝히기 위한 검사 기법
	- 비점진적 통합 방식
		- 단계적 통합 절차없이 모든 모듈을 미리 통합하여 프로그램 전체를 검사하는 방법
		- 전체 프로그램을 대상으로 하므로 오류 발견과 수정이 쉽지 않다.
	- 점진적 통합 방식
		- 모듈 단위로 단계적으로 통합하면서 검사
		- 오류 수정 용이, 인터페이스와 연관된 오류를 완전 검사 가능
		- 하향식, 상향식, 혼합식 통합 방식
		- 하향식 통합 검사(Top-Down Integration Test)
			- 프로그램 상위모듈에서 하위모듈 방향으로 통합하면서 검사
			- 주요 제어 모듈을 드라이버로 사용하고, 주요 제어 모듈의 종속 모듈들은 스터브로 대체
			- 스터브 : 일시적 필요 조건만을 가지고 임시로 제공되는 시험용 모듈
			- 스터브 사용 이유 : 상위모듈은 하위모듈이 모두 결합되어야 정상적으로 검사 가능
		- 상향식 통합 검사(Bottom-Up Integration Test)
			- 프로그램 하위 모듈에서 상위 모듈 방향으로 통합하면서 검사
            - 하위 모듈을 클러스터로 결합
            - 검사사례 입출력 조정위해 드라이버 작성
            - 클러스터 검사
            - 드라이버 제거 후 클러스터는 프로그램 구조의 상위로 이동하여 결합
		- 혼합식 통합 검사
			- 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용해 최적의 검사 지원
			- 샌드위치식 통합 검사 방법
- 검증 검사(Validation Test, 확인 검사, 인수 검사)
	- SW가 사용자의 요구사항을 충족시키는가를 중점으로 검사
	- 블랙 박스 테스트 이용
	- 형상 검사, 알파 검사, 베타 검사 등이 있다.
	- 형상 검사
		- 구성 검토 = 감사
		- SW 구성요소, 목록, 유지보수를 지원하기 위해 필요한 모든 사항들이 제대로 표현되었는지를 검사
	- 알파 검사
		- 개발자 장소에서 사용자가 개발자 앞에서 행하는 검사 기법
		- 통제된 환경에서 행해지며 오류를 사용자와 개발자가 함께 확인 및 기록
	- 베타 검사
		- 실업무에서 사용자가 직접 시험
		- 개발자에 의해 제어되지 않은 상태에서 검사, 오류는 기록 후 주기적으로 개발자에게 보고
- 시스템 검사
	- 개발된 SW가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 검사
	- 복구 검사, 보안 검사, 강도 검사, 성능 검사
	- 복구 검사 : 실패 후 올바르게 복구
	- 보안 검사 : 침투/위협로부터 시스템 보호
	- 강도 검사 : 비정상적인 양, 빈도로 호출시 SW 실행 여부
	- 성능 검사 : SW 실시간 성능을 검사, 검사단계 전 과정에 걸쳐 수행
- 디버깅
	- 검사사례에 의해 오류를 발견 후 오류를 수정하는 과정
	- 맹목적 강요 : 가장 비효율적 방법
	- 역추적(Blacktracking): 오류 발견위치에서 원인 발견 때까지의 코딩 검토/수정하는 방법
	- 원인 제거(Cause Elimination): 오류 가능성이 있는 원인을 제거해 버그를 분리
	- 단위 검사 > 코드 통합 검사 > 설계 검증 검사 > 요구사항
	 

---

# 유지보수
- SW 개발 단계 중 가장 많은 노력과 비용이 투입되는 단계
- 시험용이성, 이해성, 수정용이성, 이식성 고려 필요
- 수리 보수, 완정화 보수, 예방 보수, 적응 보수

---

### 수정 보수(Corrective)
- 시스템을 운영하면서 검사단계에서 발견못한 잠재적 오류를 수정하는 활동
- 오류 수정 및 진단

---

### 적응 보수(Adaptive = 환경 적응 = 조정 보수)
- SW 수명 주기 중 환경변화(하드웨어, OS)를 기존 SW에 반영하는 활동
- 프로그래밍 환경의 변화 또는 주변장치, 시스템 요소의 업그레이드시 대처할 수 있는 유지보수 활동

---

### 완전화 보수(Perfective, 기능 개선, 기능 보수)
- SW에 신규 기능을 추가하거나 성능을 개선/확장하는 활동
- 유지보수 활동 중 가장 큰 업무 및 비용 차지

---

### 예방 보수(Preventive = SW 재공학)
- SW 오류 발생 대비하여 미리 예방 수단을 강구하는 활동

---

### 유지보수 과정
- 유지보수 요구
- 시스템 이해
- 수정 및 시험

---

### 유지보수 비용
- SW 개발 비중 중 약 70% 차지
- Belady, Lehman에 의해 제안된 공식 사용
- https://i.imgur.com/ml3uWS2.png

---

### 유지보수 부작용
- 코딩 부작용   : 코딩 변경으로 발생
- 자료 부작용   : 자료나 자료구조 변경으로 발생
- 문서화 부작용 : 자료 코드에 대한 변경이 설계문서나 사용자 매뉴얼에 미반영 시 발생

---

### 외계인 코드(Alien Code)
- 아주 오래 전에 개발되어 유지보수 작업이 매우 어려운 프로그램
- 일반적으로 15년이 더 된 프로그램 - 문서화로 방지 가능
 

---

# 객체지향 SW 공학
- 현실 세계의 개체를 하나의 객체로 만들어 객체들을 조립으로 SW를 완성하는 개발 기법
- 구조적 기법의 문제점 해결
- SW 재사용 및 확장 용이, 신속개발 가능, 유지보수 용이
- 복잡한 구조의 단계적, 계층적 표현
- 현실세계 모형화로 사용자와 개발자의 이해 용이

---

### 객체(Object)
- 데이터와 데이터 처리 함수를 묶어 놓은 하나의 SW 모듈
- 데이터
	- 객체가 가지고 있는 정보(속성, 상태, 분류)
	- 속성 = 상태 = 변수 = 상수 = 자료 구조
- 함수
	- 객체 수행 기능으로 객체가 갖는 데이터를 처리하는 알고리즘
	- 객체 상태 참조 및 변경 수단
	- 기존 구조적 기법의 함수, 프로시저에 해당하는 연산기능
- 객체는 상태와 행위를 포함
- 객체 메소드는 다른 객체로부터 메세지 수신 시 수행

---

### 클래스
- 공통 속성 및 연산을 갖는 객체 집합
- 객체의 일반적 타입
- 객체 속성 및 연산 정의 틀
- 인스턴스   : 클래스의 객체화
- 인스턴스화 : 클래스로부터 새로운 객체 생성
- 슈퍼클래스(부모): 특정 클래스의 상위 클래스
- 서브클래스(자식): 특정 클래스의 하위 클래스

---

### 메세지
- 객체들 간 상호작용 수단
- 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구사항
- 메세지 수신 객체는 요구된 메소드 수행

---

### 객체지향 기법의 기본 원칙
	캡슐화, 추상화, 다형성, 정보은닉, 상속성,

--- 

- 캡슐화(Encapsulation)
	- 데이터와 데이터 처리 함수를 하나로 그룹화
	- 객체의 세부내용 외부 은폐, 재사용 용이
	- 인터페이스 단순화, 객체 간 결합도 저하

--- 

- 정보 은닉(Information Hiding)
	- 캡슐화에서 가장 중요한 개념
	- 다른 객체에게 자신의 정보를 숨기고 객체의 메서드를 통해 접근 허용
	- 객체 수정 영향 최소화 기술
	- 유지보수와 SW 확장시 오류 최소화

--- 

- 추상화(Abstraction)
	- 불필요한 부분 생략, 객체의 중요 속성 중심으로 모델화

--- 

- 상속성(Inheritance)
	- 상위 클래스의 모든 속성과 연산을 하위 클래스가 상속

--- 

- 다형성(Polymorphism)
	- 오버로딩
	- 오버라이딩

---

### 객체지향 기법의 생명주기
- 비순차적 수행
- 계획 및 분석
- 설계
- 구현
- 테스트 및 검증

---

### 객체지향 분석(OOA = Object Oriented Analysis)
- 사용자 요구 분석 및 요구된 문제와 관련된 모든 클래스, 연관된 속성과 연산, 관계 등을 정의하여 모델링
- SW 개발을 위한 비즈니스를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나눠서 분석
- 모델링 구성요소인 클래스, 속성, 연산 등을 표현해서 문제를 모형화
- 객체는 클래스로부터 인스턴스화, 클래스를 식별하는 것이 객체지향 분석의 주요한 목적

--- 

### 객체지향 분석 방법론
	Rumbaugh 방법, Booch 방법, jacobson 방법, Coad와 Yourdon 방법, Wirfs-Brock 방법, 

--- 

- Rumbaugh 방법
	- 가장 일반적
	- 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행

--- 

- Booch 방법
	- 미시적 Micro 개발 프로세스와 거시적 Macro 개발 프로세스 모두를 사용하는 분석 방법
	- 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의

--- 

- jacobson 방법
	- Use Case를 강조하여 사용하는 분석 방법

--- 

- Coad와 Yourdon 방법
	- E-R 다이어그램 기반 객체 행위 모델링
- Wirfs-Brock 방법
	- 분석과 설계 간의 구분이 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법

---

### Rumbaugh 분석 기법
- 모든 SW 구성요소를 그래픽 표기법으로 모델링하는 기법
- 객체 모델링 기법: OMT, Object Modeling Technique
- 객체 모델링, 동적 모델링, 기능 모델링

--- 

- 객체 모델링(Object Modeling, 정보 모델링)
	- 관계를 규정하여 객체 다이어그램으로 표시
	- 순서
		- 객체 및 클래스 식별
		- 클래스 자료 사전 작성
		- 클래스 간 관계 정의
		- 객체 속성 및 연결 관계 정의
		- 클래스 계층화 및 모듈로 정의
		- 생성모형 반복적 검증

--- 

- 동적 모델링(Dynamic Modeling)
	- 상태 다이어그램(상태도) 이용
    - 객체들 간 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
	- 객체나 클래스의 상태, 사건을 중심으로 모델링
	- 사건 : 객체로부터 다른 객체에 자극을 주어 객체 상태를 변화시키는 것
	- 상태 : 특정시점의 객체 속성값
	- 순서
		- 시나리오 작성
		- 사건 추적도 작성
		- 사건 흐름도 작성
		- 상태도 작성

--- 

- 기능 모델링(Functional Modeling)
	- 자료 흐름도 이용
    - 다수의 프로세스 간의 자료 흐름을 중심으로 처리과정을 표현한 모델
	- 순서
		- 입출력 자료 정의
		- 자료 흐름도 상세화
		- 기능 명세서 작성
		- 제약 조건 파악
		- 최적화 기준 명세

--- 

- 객체 모델링 : 객체
- 동적 모델링 : 객체의 흐름, 상태, 행위
- 기능 모델링 : 자료 흐름, 처리 과정

---

### 객체지향 설계(Object Oriented Design)
- 객체지향 분석모델을 설계모델로 변환하는 작업
- 시스템 설계, 객체 설계 수행
- 사용자 중심, 대화식 프로그램 개발에 적합
- 시스템을 구성하는 객체와 속성, 연산을 인식하는 것이 중요한 문제
- 추상화, 정보 은닉, 기능 독립성, 모듈화, 상속성을 바탕으로 하며 모듈화 중요
- 문제 정의 => 요구 명세화 => 객체 연산자 정의 => 객체 인터페이스 결정 => 객체 구현
- Rumbaugh 객체지향 설계
	- 가장 많이 사용
	- 시스템 설계 : 전체적 시스템 구조 설계
        - 분석 모델을 서브시스템으로 분할
        - 시스템 계층 정의
        - 분할 과정 중에서 최적 성능 방안, 문제해결 전략, 자원 분해 등을 확정
	- 객체 설계   : 
        - 분석 단계의 클래스, 속성, 관계, 메세지를 이용한 통신들을 설계 모델로 제작/상세화
        - 구체적 자료 구조와 알고리즘 정의
- Booch 객체지향 설계
	- 자료 흐름도를 이용하여  객체 분해 및 객체 간 인터페이스를 Ada 프로그램으로 변환
- Willium Lorenson 객체 지향 설계
	- OOD 개념들을 직접 지원하는 기능이 있는 Smalltalk과 같은 프로그래밍 언어로 SW를 개발하는 기법

---

### 객체지향 구현
- 설계 단계의 설계 모델과 명세서를 근거로 코딩하는 단계
- 객체지향 프로그래밍 이용하여 용이하게 구현
- 객체는 순차적 또는 동시적 구현 가능
- 객체지향 프로그래밍(Object Oriented Programming)
	- 객체 기반 언어   : 객체 개념만 지원하는 언어
	- 객체 지향 언어   : 객체, 클래스, 상속의 개념을 모두 지원하는 언어
        - Simula, Smalltalk, C++, Objective C, Java
	- 클래스 기반 언어 : 객체와 클래스 개념을 지원하는 언어

---

### 객체지향 테스트
- 클래스 테스트 : 캡슐화 된 클래스나 객체를 검사
- 통합 테스트   : 객체를 결합하여 하나의 시스템으로 통합시키는 과정의 검사
	- 스레드 기반 테스트
	- 사용 기반 테스트
- 확인 테스트   : 사용자 요구사항 만족 여부 검사
- 시스템 테스트 : 모든 요소 통합 및 올바른 기능 수행 검사

---

### UML(Unified Modeling Language)
- Rumbaugh, Booch, Jacobson 등의 객체지향 방법론의 장점을 통합한 객체지향 모델의 표준 표현 방법
- 객체지향 분석과 설계를 위한 모델링 언어
- 객체 기술에 관한 국제 표준화 기구(Object Management Group)에서 UML을 표준으로 지정
- 유즈케이스 다이어그램, 순서 다이어그램, 상태 다이어그램, 활동 다이어그램 등 여러 다이어그램 제공
- UseCase 다이어그램: 기능 모델링
	- Use Case 명세
	- 사용자와 사용사례로 구성
	- 사용 사례 간에는 여러 형태의 관계 포함
- 클래스 다이어그램 : 객체 모델링
- 순서 다이어그램   : 동적 모델링
- 상태 다이어그램   : 동적 모델링
- 활동 다이어그램   : 동적 모델링
 

---

# SW 재사용(Reuse)
- 이미 개발된 SW의 전체 혹은 일부를 다른 SW 개발이나 유지보수에 사용하는 기법
- 모듈 크기가 작고 일반적인 설계일수록 재사용률이 높다.

---

### 재사용의 이점
- 개발 시간과 비용의 단축
- SW 품질 향상
- 개발 생산성 향상
- 프로젝트 실패 위험 감소
- 시스템 구축 방법에 대한 지식 공유
- 시스템 명세, 설계, 코드 등 문서를 공유

---

### 재사용의 문제점
- 새로운 개발방법론 도입이 어려움
- 프로그램 표준화가 부족
- 프로그램 언어가 종속적
- SW 요소 내부 뿐아니라 인터페이스 요구사항의 이해가 필요하다.

---

### 재사용 방법
- 합성 중심 방법
	- Composition Based = 블록 구성 방법
	- 모듈을 만들어 조립하며 SW를 완성시키는 방법
- 생성 중심
	- Generation Based = 패턴 구성 방법
	- 추상화 형태로 쓰여진 명세를 구체화하여 SW를 완성시키는 방법
	 

---

# SW 재공학
- Software Reengineering
- 새로운 요구에 맞도록 기존 시스템을 이용하여 보다 나은 시스템을 구축
- 새로운 기능을 추가하여 SW 성능을 향상
- 유지보수 생산성 향상을 통해 SW 위기를 해결
- 기존 SW의 기능을 개조하거나 개선하므로 예방 유지보수 측면
- 자동화된 도구를 사용하여 SW를 분석하고 수정하는 과정을 포함
- SW 수명이 연장되고 기술이 향상
- 오류가 줄어들고 비용이 절감
- 예방 유지보수
 

---

### 재공학의 목표
- 복잡한 시스템을 다루는 방법 구현 : 자동화 도구 사용
- 다른 뷰의 생성 : 기존 시스템 개발 관점 외에 다른 방향의 관점을 생성
- 잃어 버린 정보의 복구 및 제거
- 부작용의 발견
- 고수준의 추상 : 추상화된 어려운 내용을 여러 형태로 추출해 이해
- 재사용 용이
 

---

### 주요활동
- 분석
	- Analysis
	- 기존 SW의 명세서를 확인하여 SW의 동작을 이해하고 재공학 대상을 선정하는 것
- 개조
	- Restructuring = 재구조 - 재구성
	- 상대적으로 같은 추상적 수준에서 하나의 표현을 다른 표현 형태로 바꾸는 것
	- 기존 SW의 구조를 향상시키기 위해 코드를 재구성 하는 것
	- SW의 기능과 외적인 동작은 바뀌지 않는다.
	- IF ELSE를 SWITCH CASE로 변경하듯이
- 역공학
	- Reverse Engineering
	- 기존 SW를 분석하여 SW 개발 과정과 데이터 처리 과정을 설명하는 분석 및 설계 정보를 재발견하거나 다시 만들어 내는 작업
	- 기존 코드를 복구하는 방법
	- 대상 SW가 가능하다.
	- 코드 역공학 : 코드 => 흐름도 => 자료 구조도 => 자료 흐름도
	- 데이터 역공학 : 코드 => 자료 사전 => 개체 관계도
	- 재문서화 : Redocumentation 역공학의 가장 간단하고 오래된 형태
- 이식
	- Migration
	- 기존 SW를 다른 운영체제나 하드웨어 환경에서 사용할 수 있도록 변환하는 작업

---

# Client/Server 시스템
- 분산 시스템의 가장 대표적인 모델
- 정보를 제공하는 서버와 정보를 요구하는 클라이언트로 구성
- 클라이언트와 서버가 하나의 작업을 분산 협동 처리한다.

---

### 요소
- 애플리케이션 요소 : 응용 프로그램에 의해 정의된 요구사항을 구현
- 데이터베이스 요소
- 프리젠테이션/상호작용 요소 : GUI와 관련된 모든 기능

---

### 미들웨어
- 클라이언트와 서버 사이에 존재해서 데이터 전송 과정을 효율적으로 수행하도록 도와주는 SW
- 통신 미들웨어 : NOS(Network Operating System)
- 데이터베이스 미들웨어 : ODBC
- 분산 객체 미들웨어 : CORBA, DCOM

---

### 객체 요청 브로커
- ORB = Object Request Broker
- 분산 객체 미들웨어의 일종
- 클라이언트의 객체가 서버 객체의 캡슐화된 메소드에게 메세지를 보낼 수 있게 하는 것

---

### CORBA
- Common Object Request Broker Architecture
- 가장 많이 사용되는 객체 요청 브로커의 표준
- OMG(Obejct Management Group)라는 개발자 연합에서 인가
- IDL : Interface Description Language CORBA가 클라이언트/서버 시스템에서 구현될 때 필요한 인터페이스 언어


---

# CASE
- Computer Aided Software Engineering
- SW 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 SW 도구를 사용하여 자동화하는 것
- SW 개발 도구와 방법론이 결합된 것
- 정형화된 구조 및 방법을 SW 개발에 적용하여 생산성 향상을 구현하는 공학 기법
- 자동화 도구를 지원하고 개발자는 SW 개발의 표준화를 지향하며 자동화의 이점을 얻을 수 있다.
- SW 생명주기 전 단계의 연결, 다양한 SW 개발 모형 지원, 그래픽 지원

---

### 사용 이점
- SW 개발 기간 단축하고 개발 비용 절감
- 자동화된 기법을 통해 SW 품질 향상
- 유지보수 간편하게 수행
- 생산성 향상
- 운용 활동 효과적으로 관리 및 통제
- 품질과 일관성을 효과적으로 제어
- SW 개발 모든 단계에 걸친 표준 확립
- 모듈의 재사용성 향상
- 개발 기법의 실용화, 문서화가 쉬움

---

### 분류
- 상위 CASE
	- Upper CASE
	- SW 생명 주기 전반부에서 사용
	- 문제를 기술하고 계획하며 요구 분석과 설계 단계를 지원
	- 여러가지 명세와 문서를 작성하는데 사용
	- SREM, PSL/PSA, SERA, FOUNDATION
- 하위 CASE
	- Lower CASE
	- SW 생명 주기 하반부에서 사용
	- 코드의 작성과 테스트, 문서화하는 과정을 지원
	- 구문 중십 편집기, 코드 생성기
- 통합 CASE
	- Integrate CASE
	- SW 생명 주기 포함되는 전체 과정을 지원
	- 공통의 정보 저장 장소와 통일된 사용자 인터페이스를 사용하여 도구를 통합
	- IEF, POWERTOOLS, TAGS/IORL, TEAMWORK

---

### 정보 저장소
- SW를 개발하는 과정 동안 모아진 정보를 보관하여 관리하는 곳
- CASE 정보 저장소 = CASE 데이터베이스 = 요구사항 사전 = 저장소
- 초기에는 사람이 정보 저장소, 오늘은 DB가 정보 저장소
- 도구들의 통합, SW 시스템의 표준화, SW 시스템의 정보 공유, SW 재사용성의 기본
- 시스템의 정보 공유 활성화
- 유지보수성 향상
- CASE 도구간 정보를 쉽게 교환, 사용자가 새로운 도구를 쉽게 추가
- 중복된 공통정보를 통합해 불필요한 정보 제거
- 생명 주기 정보를 재사용
- SW 시스템의 이삭과 변환을 용이하게 함
